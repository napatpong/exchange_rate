const puppeteer = require('puppeteer');
const fs = require('fs');
const path = require('path');
const dayjs = require('dayjs');

// ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ dayjs
require('dayjs/locale/th');
dayjs.locale('th');

function isBusinessHours(timeString) {
  if (!timeString) return false;

  const [hour] = timeString.split(':').map(Number);
  const isInRange = hour >= 8 && hour < 16; // 8:00-15:59
  
  return isInRange;
}

async function exportKbankRatesToPDF() {
  let browser;
  try {
    console.log('üîó Loading website...');
    browser = await puppeteer.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-accelerated-2d-canvas',
        '--no-first-run',
        '--no-zygote',
        '--disable-gpu'
      ],
      defaultViewport: { width: 1920, height: 1080 }
    });
    
    const page = await browser.newPage();
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36');
    
    await page.setRequestInterception(true);
    page.on('request', (req) => {
      const resourceType = req.resourceType();
      const url = req.url();
      if (resourceType === 'script' && (
        url.includes('google-analytics') ||
        url.includes('googletagmanager') ||
        url.includes('facebook') ||
        url.includes('hotjar') ||
        url.includes('cookie') ||
        url.includes('consent') ||
        url.includes('analytics') ||
        url.includes('tracking')
      )) {
        req.abort();
      } else {
        req.continue();
      }
    });

    await page.goto('https://www.kasikornbank.com/th/rate/Pages/Foreign-Exchange.aspx', {
      waitUntil: 'domcontentloaded',
      timeout: 30000
    });

    await new Promise(resolve => setTimeout(resolve, 10000));
    console.log('‚úÖ Website loaded successfully');

    // ‡∏õ‡∏¥‡∏î cookie popups
    try {
      const cookieSelectors = [
        '[data-testid="cookie-banner"]', '.cookie-consent', '.cookie-banner', 
        '.cookie-popup', '.cookies-popup', '.gdpr-popup', '.consent-banner',
        '#cookie-consent', '#cookieConsent', '.modal-backdrop', '.cookie-overlay',
        '[class*="cookie"]', '[id*="cookie"]', 'button[aria-label*="cookie"]',
        'button[aria-label*="‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö"]', 'button[aria-label*="accept"]'
      ];
      
      for (const selector of cookieSelectors) {
        try {
          const element = await page.$(selector);
          if (element) {
            await element.evaluate(el => el.remove());
          }
        } catch (e) {}
      }
      
      const acceptButtons = await page.$$('button');
      for (const button of acceptButtons) {
        const text = await button.evaluate(el => el.textContent ? el.textContent.toLowerCase() : '');
        if (text.includes('‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö') || text.includes('accept') || text.includes('‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï')) {
          await button.click();
          break;
        }
      }
    } catch (error) {
      // No cookie popups found
    }

    // ‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏á‡∏™‡πÑ‡∏ï‡∏•‡πå‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö
    await page.addStyleTag({
      content: `
        header, nav, footer, .navbar, .menu, .sidebar, .advertisement, .ads {display: none !important;} 
        body {margin: 0; padding: 10px;} 
        .container {max-width: 100%;} 
        table, td, th {font-size: 18px !important;} 
        td {padding: 12px !important;} 
        th {padding: 14px !important; font-weight: bold !important;} 
        @media print { 
          @page { margin-top: 50px; margin-bottom: 30px; } 
          @page:first { margin-top: 10px; }
          table, td, th {font-size: 18px !important;}
        }
      `
    });

    // ‡∏≠‡πà‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡πÄ‡∏ß‡πá‡∏ö‡πÑ‡∏ã‡∏ï‡πå
    console.log('üìñ Reading page information...');
    const pageInfo = await page.evaluate(() => {
      let debugInfo = {
        foundPatterns: [],
        elementFound: false,
        elementText: ''
      };

      // ‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å element ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
      const dateElement = document.querySelector('#ModDate') || document.querySelector('.date-data');
      
      let dateInfo = null;
      let timeInfo = null;
      let roundInfo = null;

      if (dateElement) {
        const elementText = dateElement.textContent || dateElement.innerText;
        debugInfo.elementFound = true;
        debugInfo.elementText = elementText;
        debugInfo.foundPatterns.push('Found element #ModDate: ' + elementText);
        debugInfo.foundPatterns.push('Element text cleaned: "' + elementText.replace(/\s+/g, ' ').trim() + '"');

        // ‡πÅ‡∏¢‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏≤‡∏£‡∏´‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°
        debugInfo.foundPatterns.push('Parsing with string methods');
        
        try {
          // ‡∏´‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏•‡∏∞‡πÄ‡∏î‡∏∑‡∏≠‡∏ô (‡πÉ‡∏ä‡πâ Unicode range ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÑ‡∏ó‡∏¢)
          const dayMatch = elementText.match(/(\d{1,2})\s+([\u0E00-\u0E7F]+)\s+(\d{4})/);
          const timeMatch = elementText.match(/(\d{1,2}):(\d{2}):(\d{2})/);
          const roundMatch = elementText.match(/(\d+)$/); // ‡πÄ‡∏•‡∏Ç‡∏ó‡πâ‡∏≤‡∏¢‡∏™‡∏∏‡∏î
          
          if (dayMatch) {
            const day = parseInt(dayMatch[1]);
            const monthName = dayMatch[2];
            const year = parseInt(dayMatch[3]);
            
            // ‡πÅ‡∏õ‡∏•‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏î‡∏∑‡∏≠‡∏ô‡πÑ‡∏ó‡∏¢‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
            const thaiMonths = {
              '‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°': '01', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå': '02', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°': '03', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô': '04',
              '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°': '05', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô': '06', '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°': '07', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°': '08',
              '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô': '09', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°': '10', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô': '11', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°': '12'
            };
            const month = thaiMonths[monthName] || '01';
            
            // ‡πÅ‡∏õ‡∏•‡∏á‡∏õ‡∏µ ‡∏û.‡∏®. ‡πÄ‡∏õ‡πá‡∏ô ‡∏Ñ.‡∏®.
            const adYear = year > 2500 ? year - 543 : year;
            
            dateInfo = {
              day: day,
              month: month,
              year: adYear,
              dateString: `${adYear}-${month}-${String(day).padStart(2, '0')}`,
              found: true,
              matchedText: `‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà ${day} ${monthName} ${year}`
            };
            debugInfo.foundPatterns.push('Date parsed: ' + dateInfo.dateString);
          }
          
          if (timeMatch) {
            const hour = parseInt(timeMatch[1]);
            const minute = parseInt(timeMatch[2]);
            const second = parseInt(timeMatch[3]);
            
            timeInfo = {
              hour: hour,
              minute: minute,
              second: second,
              timeString: `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`,
              fullTimeString: `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:${String(second).padStart(2, '0')}`,
              found: true,
              matchedText: `‡πÄ‡∏ß‡∏•‡∏≤ ${timeMatch[0]}`
            };
            debugInfo.foundPatterns.push('Time parsed: ' + timeInfo.fullTimeString);
          }
          
          if (roundMatch) {
            const round = parseInt(roundMatch[1]);
            roundInfo = {
              found: true,
              roundNumber: round,
              fullText: `‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà ${round}`
            };
            debugInfo.foundPatterns.push('Round parsed: ' + round);
          }
          
        } catch (parseError) {
          debugInfo.foundPatterns.push('Parse error: ' + parseError.message);
        }
      } else {
        debugInfo.foundPatterns.push('Element #ModDate or .date-data not found');
        
        // ‡∏´‡∏≤‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÅ‡∏¢‡∏Å - ‡∏Ç‡∏¢‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤
        const datePatterns = [
          /‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà\s*(\d{1,2})\s*(\w+)\s*(\d{4})/,                    // ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà 12 ‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô 2568
          /(\d{1,2})\s*(\w+)\s*(\d{4})\s*‡πÄ‡∏ß‡∏•‡∏≤/,                     // 12 ‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô 2568 ‡πÄ‡∏ß‡∏•‡∏≤
          /‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà\s*(\d{1,2})\s*\/\s*(\d{1,2})\s*\/\s*(\d{4})/,     // ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà 12/09/2568
          /(\d{1,2})\s*\/\s*(\d{1,2})\s*\/\s*(\d{4})\s*‡πÄ‡∏ß‡∏•‡∏≤/        // 12/09/2568 ‡πÄ‡∏ß‡∏•‡∏≤
        ];
        
        // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ó‡∏±‡πâ‡∏á‡πÉ‡∏ô textContent ‡πÅ‡∏•‡∏∞ innerHTML
        const htmlContent = document.documentElement.innerHTML;
        const searchTexts = [bodyText, htmlContent];
        
        for (const searchText of searchTexts) {
          if (dateInfo) break;
          
          for (const pattern of datePatterns) {
            const match = searchText.match(pattern);
            if (match && !dateInfo) {
              debugInfo.foundPatterns.push('Date pattern in ' + (searchText === bodyText ? 'text' : 'HTML') + ': ' + match[0]);
              
              let day, month, year;
              if (pattern.toString().includes('\\w+')) { // ‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏î‡∏∑‡∏≠‡∏ô
                day = parseInt(match[1]);
                const monthName = match[2];
                year = parseInt(match[3]);
                
                const thaiMonths = {
                  '‡∏°‡∏Å‡∏£‡∏≤‡∏Ñ‡∏°': '01', '‡∏Å‡∏∏‡∏°‡∏†‡∏≤‡∏û‡∏±‡∏ô‡∏ò‡πå': '02', '‡∏°‡∏µ‡∏ô‡∏≤‡∏Ñ‡∏°': '03', '‡πÄ‡∏°‡∏©‡∏≤‡∏¢‡∏ô': '04',
                  '‡∏û‡∏§‡∏©‡∏†‡∏≤‡∏Ñ‡∏°': '05', '‡∏°‡∏¥‡∏ñ‡∏∏‡∏ô‡∏≤‡∏¢‡∏ô': '06', '‡∏Å‡∏£‡∏Å‡∏é‡∏≤‡∏Ñ‡∏°': '07', '‡∏™‡∏¥‡∏á‡∏´‡∏≤‡∏Ñ‡∏°': '08',
                  '‡∏Å‡∏±‡∏ô‡∏¢‡∏≤‡∏¢‡∏ô': '09', '‡∏ï‡∏∏‡∏•‡∏≤‡∏Ñ‡∏°': '10', '‡∏û‡∏§‡∏®‡∏à‡∏¥‡∏Å‡∏≤‡∏¢‡∏ô': '11', '‡∏ò‡∏±‡∏ô‡∏ß‡∏≤‡∏Ñ‡∏°': '12'
                };
                month = thaiMonths[monthName] || '01';
              } else { // ‡πÄ‡∏•‡∏Ç/‡πÄ‡∏•‡∏Ç/‡∏õ‡∏µ
                day = parseInt(match[1]);
                month = String(parseInt(match[2])).padStart(2, '0');
                year = parseInt(match[3]);
              }
              
              const adYear = year > 2500 ? year - 543 : year;
              dateInfo = {
                day: day,
                month: month,
                year: adYear,
                dateString: `${adYear}-${month}-${String(day).padStart(2, '0')}`,
                found: true,
                matchedText: match[0]
              };
              break;
            }
          }
        }

        // ‡∏´‡∏≤‡πÄ‡∏ß‡∏•‡∏≤‡πÅ‡∏¢‡∏Å
        const timePatterns = [
          /‡πÄ‡∏ß‡∏•‡∏≤\s*(\d{1,2}):(\d{2}):(\d{2})/,
          /(\d{1,2}):(\d{2}):(\d{2})\s*‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà/
        ];
        
        for (const pattern of timePatterns) {
          const match = bodyText.match(pattern);
          if (match && !timeInfo) {
            debugInfo.foundPatterns.push('Time pattern: ' + match[0]);
            
            const hour = parseInt(match[1]);
            const minute = parseInt(match[2]);
            const second = parseInt(match[3]);
            
            timeInfo = {
              hour: hour,
              minute: minute,
              second: second,
              timeString: `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`,
              fullTimeString: `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:${String(second).padStart(2, '0')}`,
              found: true,
              matchedText: match[0]
            };
          }
        }

        // ‡∏´‡∏≤‡∏£‡∏≠‡∏ö‡πÅ‡∏¢‡∏Å
        const roundMatch = bodyText.match(/‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà\s*(\d+)/);
        if (roundMatch) {
          debugInfo.foundPatterns.push('Round pattern: ' + roundMatch[0]);
          roundInfo = {
            found: true,
            roundNumber: parseInt(roundMatch[1]),
            fullText: roundMatch[0]
          };
        }
      }

      return {
        date: dateInfo,
        time: timeInfo,
        round: roundInfo,
        debug: debugInfo
      };
    });

    console.log('üìä Page info extracted:');
    
    // ‡πÅ‡∏™‡∏î‡∏á debug ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    if (pageInfo.debug) {
      console.log('üîç Debug - Found patterns:');
      pageInfo.debug.foundPatterns.forEach((pattern, idx) => {
        console.log(`  ${idx + 1}: ${pattern}`);
      });
      // ‡∏•‡∏ö debug text sample ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏õ‡∏±‡∏ç‡∏´‡∏≤
    }

    if (pageInfo.date && pageInfo.date.found) {
      console.log(`üìÖ Date: ${pageInfo.date.dateString} (${pageInfo.date.matchedText})`);
    } else {
      console.log('üìÖ Date: Not found from website');
    }

    if (pageInfo.time && pageInfo.time.found) {
      console.log(`‚è∞ Time: ${pageInfo.time.fullTimeString} (${pageInfo.time.matchedText})`);
    } else {
      console.log('‚è∞ Time: Not found from website');
    }

    if (pageInfo.round && pageInfo.round.found) {
      console.log(`üî¢ Round: ${pageInfo.round.roundNumber} (${pageInfo.round.fullText})`);
    } else {
      console.log('üî¢ Round: Not found');
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤ 8:00-16:00
    if (pageInfo.time && pageInfo.time.found) {
      if (!isBusinessHours(pageInfo.time.timeString)) {
        console.log(`‚ö†Ô∏è Time ${pageInfo.time.timeString} is outside business hours (8:00-15:59) - Skipping export`);
        if (browser) {
          await browser.close();
        }
        return;
      }
      console.log(`‚úÖ Time ${pageInfo.time.timeString} is within business hours - Proceeding with export`);
    } else {
      console.log('‚ö†Ô∏è Cannot determine time from website - Skipping export for safety');
      if (browser) {
        await browser.close();
      }
      return;
    }

    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå
    let dateForFilename;
    if (pageInfo.date && pageInfo.date.found) {
      dateForFilename = pageInfo.date.dateString;
    } else {
      console.log('‚ö†Ô∏è Cannot determine date from website - Skipping export for safety');
      if (browser) {
        await browser.close();
      }
      return;
    }

    const dateParts = dateForFilename.split('-');
    const year = dateParts[0];
    const monthNames = ['', 'January', 'February', 'March', 'April', 'May', 'June',
                       'July', 'August', 'September', 'October', 'November', 'December'];
    const month = monthNames[parseInt(dateParts[1])];

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå
    const folderPath = path.join('/mnt/synonas/exchange', 'K-BANK', year, month);
    if (!fs.existsSync(folderPath)) {
      fs.mkdirSync(folderPath, { recursive: true });
      console.log(`üìÅ Created folder: ${folderPath}`);
    }

    // ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå
    let filename;
    if (pageInfo.round && pageInfo.round.found) {
      const roundFilename = `k-bank ${dateForFilename} #${pageInfo.round.roundNumber}.pdf`;
      const roundFilePath = path.join(folderPath, roundFilename);
      if (fs.existsSync(roundFilePath)) {
        console.log(`‚ö†Ô∏è File already exists: ${roundFilename}`);
        if (browser) {
          await browser.close();
        }
        return;
      }
      filename = roundFilePath;
      console.log(`üìù Will create: ${roundFilename}`);
    } else {
      // ‡∏´‡∏≤‡πÄ‡∏•‡∏Ç‡∏£‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏ñ‡∏±‡∏î‡πÑ‡∏õ
      let sequenceNumber = 1;
      const baseFilename = `k-bank ${dateForFilename}`;
      if (fs.existsSync(folderPath)) {
        const existingFiles = fs.readdirSync(folderPath);
        const todayFiles = existingFiles.filter(file => file.startsWith(baseFilename) && file.endsWith('.pdf'));
        if (todayFiles.length > 0) {
          const numbers = todayFiles.map(file => {
            const match = file.match(/#(\d+)\.pdf$/);
            return match ? parseInt(match[1]) : 0;
          });
          sequenceNumber = Math.max(...numbers) + 1;
        }
      }
      filename = path.join(folderPath, `${baseFilename} #${sequenceNumber}.pdf`);
      console.log(`üìù Will create: ${baseFilename} #${sequenceNumber}.pdf`);
    }

    // ‡∏™‡∏£‡πâ‡∏≤‡∏á PDF
    console.log('üìÑ Generating PDF...');
    await page.pdf({
      path: filename,
      format: 'A4',
      printBackground: true,
      margin: {
        top: '50px',
        bottom: '200px',
        left: '20px',
        right: '20px'
      },
      displayHeaderFooter: true,
      headerTemplate: `<div style="font-size: 10px; text-align: center; width: 100%; margin: 0 20px;"><span>Kasikorn Bank - Foreign Exchange Rates</span></div>`,
      footerTemplate: `<div style="font-size: 10px; text-align: center; width: 100%; margin: 0 20px;"><span>Generated on ${dayjs().format('DD/MM/YYYY HH:mm:ss')} | Page <span class="pageNumber"></span> of <span class="totalPages"></span></span></div>`
    });
    console.log(`‚úÖ PDF created successfully: ${path.basename(filename)}`);

  } catch (error) {
    console.error('‚ùå Error occurred:', error.message);
  } finally {
    if (browser) {
      await browser.close();
      console.log('üîí Browser closed');
    }
  }
}

if (require.main === module) {
  exportKbankRatesToPDF()
    .then(() => {
      process.exit(0);
    })
    .catch((error) => {
      console.error('üí• K-Bank export failed:', error);
      process.exit(1);
    });
}

module.exports = {
  exportKbankRatesToPDF
};